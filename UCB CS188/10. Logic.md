# 1. Basics of logic
## 1.1 Basic language of logic:
+ **Not**: $\lnot p = true$ **if and only if** $p = false$
+ **And**: $A\land B = true$ **IFF** $A=B=true$
+ **Or**: $A\lor B = true$ **IFF** at least one of $\{A,B\}$ is $true$.
+ **Implication**: $(A\Rightarrow B) = true$ **IFF** 
    1. $B=true$
    2. $A=false$.  
   i.e. $(A\Rightarrow B) = (\lnot A)\lor B$
+ **biconditional**: $A\Leftrightarrow B = true$ **IFF** $A=B$

## 1.2 Property of basic operation of logic:
![img](https://img2024.cnblogs.com/blog/3668476/202601/3668476-20260121141317056-1182936802.png)
<!--![alt text](image-10.png)-->

# 2 Propositional logic
**PRopositional logic** composed of **proposition symbols** and **logic connectives**.
+ **Proposition symbols**:
  + We use a uppercase letter to represent an **atomic proposition**, which is an indivisible fundamental statement about the world.
  + e.g. $A=\{\text{I fuck the HKU}\}$
+ **Model**: A complete assignment method for all propositional symbols(True of False).

There are three types of a sentence(the combination of propositions):
+ Valid/Tautology:
  + Is **true** for all models
+ Satisfiable
  + There is at least one model make it true
+ Unsatisfiable/Comtradiction
  + Is **false** for all models

## 2.1 CNF Conjunctive Normal Form
CNF is a standard form of proposition, composed of many **subsentence**, each subsentence is composed of many **literals**, combinated by $\land$.   
i.e.
$$
(A_1\lor A_2\lor\dots)\land(B_1\lor B_2\lor\dots)\land\dots
$$

# 3. Propositional Logical Inference & DPLL

Firstly we define a terminology:
+ $A$ **entails** $B$ (A 语义蕴含 B):
   + Represented as $A\models B$
   + If in all models $A$ is true, then B is as well.

We consider the problem: How to prove that $A \models B$?

There are two way of proof:
## 3.1 Proof
1. **Direct Proof**
   1. $A\models B$ IFF $A\Rightarrow B$ is valid
2. **Proof by contradiction**
   1. $A\models B$ IFF $A\land \lnot B$ is unsatisfiable

## 3.2 Model Checking
We can check all models looking for is ther exist a model that $A=true=\lnot B$ But it's $O(2^N)$ time complexity where $N$ is the number of symbols, which is a **co-NP-complete** problem. So the brute way is unefficient in practice. 

### 3.2.1 DPLL (Davis, Putnam, Logemann, and Loveland) Algorithm
**Goal**: To find the possible model that satisfy some constraint(a **CNF**).
> i.e. solve the **SAT** problem

There are three step for DPLL:
1. **Early Termination**:
   1. Note that the sentence is false if any single clause is false. So we early check before any assignment of symbols.
   2. For the **current assignment**
      1. If the whole sentence is true, then we find it(Obviously haha)
      2. If any clause is false, then the **current path** is wrong, we **backtrack**
2. **Pure Symbol Heuristic**:
   1. We called a symbol is **pure** if **it only show up in same form**, i.e. only exist $A$ or $\lnot A$ in all clause.
   2. For all **pure symbol**:
      1. If it only show up in positive form, then assign it with true
      2. Else, assign it with false
3. **Unit Caluse Heuristic**
   1. We called a clause is **unit** if it only has exactly 1 unassigned symbol (e.g. $(A\lor false\lor false\dots\lor false)$)
   2. If a clause is unit, then we assign its only unassigned symbol to make it true.

After the above 3 pruning strategy, we can efficient search the goal model by backtracking.

### 3.2.2 Theorem proving
We can also check by **inference to knowedge base(KB)**.
1. **Modus Ponens**
   1. If the knowledge base contains $A$ and $A\Rightarrow B$, then we can infer $B$
2. **And-Elimination**
   1. If the knowledge base contains $A$ and $A\land B$, then we can infer $B$
3. **And-Introduction**
   1. If the knowledge base contains $A$ and $B$, then we can infer $A\land B$
4. **Resolution**:
   1. $(A\lor B)\land (\lnot V\lor C)\Rightarrow (A\lor C)$
   
#### forward chaining
There is a sqecial  called **Horn Clause**, which is shaped like:
$$
P_1\land P_2\land\dots\land P_n\Rightarrow Q
$$
Where $P_i$ and Q are **literals**
In form CNF is:
$$
\lnot P_1\lor \lnot P_2\lor\dots\lor\lnot P_n\lor Q
$$

Process of **Forward chaining**:
1. Initiate `known`, which is the collection of all **Literals** in KB
2. Repeatly traverse all **Horn clauses** form as $P_1\land P_2\land\dots\land P_n\Rightarrow Q$
   1. If $\forall P_i\in known, but $Q\notin known$:
      1. Join $Q$ into `known`.  
  
$O(n)$ complexity!